---
layout: user_guide
title: Pangool - User guide - Group & Sort by
---
<div class="hero-unit">
	<h1>Pangool User Guide</h1>
</div>

<h1>Group-by & Order-by</h1>

<p>
Pangool was conceived to solve in a simple way how records emitted in the Map stage
are grouped and ordered when they reach the Reduce phase.
</p>
<p>
Pangool allows tuples be grouped by a subset of their fields. For instance:
</p>

<p>
<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("my_schema",Fields.parse("url:string, timestamp:long")));
 b.setGroupByFields(“url”);
</pre>
</p>

<p>
In the example above tuples containing a <code>url</code> and <code>timestamp</code> arrive to the 
<i>Reduce</i> stage grouped by <code>url</code>.<br>
This is a trivial case which can be easily achieved by using plain MapReduce, 
but let's complicate things a bit more..
</p>

<p>
Let's say that you want tuples to be ordered in descending "url" order. In Pangool this is as easy 
as adding:
</p>

<p>
<pre class="prettyprint" id="java">
 b.setOrderBy(new OrderBy().add("url", Order.DESC))
</pre>
</p>

<p>
As shown above, just adding a new line allows us to define the criteria (ASC / DESC) used to sort tuples.
This is apparently straight-forward, however plain MapReduce usually forces you to 
specify custom comparators to perform this simple task.
</p>

<p>
Let's complicate things further. Imagine that you still want to group tuples
by their <code>url</code> but you also need them be ordered by descending <code>timestamp</code>
for each group.
In this case the ordering criteria contains the fields <code>url</code> and <code>timestamp</code> which
exceed those that we defined in "group by" (<code>url</code>).
</p>
<p>
This way of ordering is called <b>Secondary Order</b> and it's achieved easily in Pangool by adding:
</p>

<p>
<pre class="prettyprint" id="java">
 b.setGroupByFields("url");
 b.setOrderBy(new OrderBy().add("url",Order.DESC).add("timestamp",Order.DESC))
</pre>
</p>

<p>
As shown in the snippet above, the fields defined in "order by" include those in "group by". This is a restriction 
in Pangool, where <i>Group-By</i> <b>must be a prefix</b> of <i>Order-By</i>.
</p>
Contrary to what it looks, this is tough to achieve in plain Map-Reduce, especially when  
several fields are involved in grouping and ordering. Programming in plain
Map-Reduce usually forces you to define custom logic for binary comparison, grouping and partitioning.
Pangool excels in this task, removing all this burden and offering it to you with no pain.
</p>


<div class="alert alert-info">
<p><b>Note:</b>
The partitioning strategy that Pangool chooses is coherent with the group-by / sort-by criterias.
In this case, Pangool will partition by the Group-by fields unless we modify the default 
partitioning strategy. See the <a href="partitioner.html">Custom Partitioners</a> section for more about this.
</p>

</div>

<h2>Multi-schema Sort-By</h2>

<p>
When multiple intermediate schemas are defined and a Reduce-side Join is performed 
(see <a href="joins.html">joins</a> section) then Sort-By shows us more options and advanced 
features. Let's see the next example:
</p>

<p>
<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("urls_register",Fields.parse("url:string,timestamp:long")));
 b.addIntermediateSchema(new Schema("urls_map",Fields.parse("url:string,canonical_url:string")));
 b.setGroupByFields(“url”);
</pre>
</p>

<p>
Usually when performing Joins the desired behavior is to receive tuples from one data source before than
tuples from the other.
This eases programming and avoids having to keep data in memory before performing the actual
join business logic. (For instance, in a Cross-Product).
In Pangool this is achieved adding this:
</p>

<pre class="prettyprint" id="java">
 b.setGroupByFields(“url”);
 b.setOrderBy(new OrderBy().add("url", Order.ASC).addSchemaOrder(Order.DESC)));
</pre>

<p>
The special method <code>addSchemaOrder</code> in <code>OrderBy</code> indicates that 
tuples, after being ordered by <code>url</code>, they will be ordered according to the schema they belong.
That is, given the dataset below: 
</p>
<p>
<pre class="prettyprint" id="java">
 URLS_REGISTERS:
 { "url1.com", 10000 }
 { "url2.com", 20000 } 
 { "url1.com", 30000 } 
 { "url2.com", 40000 }
 { "url1.com", 20000 }  
 
 URLS_MAPS:
 { "url1.com", "http://canonical_url1.com" }
 { "url2.com", "http://canonical_url2.com" } 
 </pre>
</p>

<p>
According to the definition above :
<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("urls_register",Fields.parse("url:string,timestamp:long")));
 b.addIntermediateSchema(new Schema("urls_map",Fields.parse("url:string,canonical_url:string")));
 b.setGroupByFields(“url”);
 b.setOrderBy(new OrderBy().add("url",Order.ASC).addSchemaOrder(Order.DESC)));
</pre>

Tuples will be received in the Reduce phase in the following way:
</p>

<pre class="prettyprint" id="java">
 REDUCE_GROUP_1 ("url1.com"):
 { "url1.com", "http://canonical_url1.com" }
 { "url1.com", 10000 }
 { "url1.com", 30000 }
 { "url1.com", 20000 } 

 REDUCE_GROUP_2 ("url2.com"):   
 { "url2.com", "http://canonical_url2.com" }
 { "url2.com", 20000 }
 { "url2.com", 40000 }
 </pre>
 
<p>
Receiving the <code>canonical_url</code> first allows us to process
the remaining urls without needing to keep them in memory (or spilling them to disk).  
</p>

<div class="alert alert-info">
<p><b>Note:</b>
Any field used in <code>setOrderBy</code> must be present in every intermediate schema defined with the same name <strong>and</strong> type.
</p>
</div>

<h2>Specific Order-By</h2>

<p>
In some cases, when performing a Reduce-side join, we could be interested in ordering tuples within a particular schema in
a specific criteria. This is achieved by using the method <code>setSpecificOrderBy</code>.
We can reuse the previous example to specify a particular ordering for the tuples from <code>urls_register</code>:
</p>

<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("urls_register", Fields.parse("url:string,timestamp:long")));
 b.addIntermediateSchema(new Schema("urls_map", Fields.parse("url:string,canonical_url:string")));
 b.setGroupByFields(“url”);
 b.setOrderBy(new OrderBy().add("url", Order.ASC).addSchemaOrder(Order.DESC)));
 b.setSpecificOrderBy("urls_register", new OrderBy().add("timestamp", Order.DESC));
</pre>
 
<p>
Given the previous input dataset, the output would be :
</p> 

<pre class="prettyprint" id="java">
 REDUCE_GROUP_1 ("url1.com"):
 { "url1.com", "http://canonical_url1.com" }
 { "url1.com", 30000 }
 { "url1.com", 20000 }
 { "url1.com", 10000 } 

 REDUCE_GROUP_2 ("url2.com"):   
 { "url2.com", "http://canonical_url2.com" }
 { "url2.com", 40000 }
 { "url2.com", 20000 }
</pre>

<p>
Note how tuples from "urls_register" now come sorted by timestamp.
</p>

<h2>Sorting null values</h2>

<p>
    Since version 0.60, some tuples could carry fields with nulls values. It is important to be able
    to manage how null values are sorted when compared with a non null value. That can be controlled
    by setting the proper <code>NullOrder</code> in the <code>OrderBy</code> definition. The possible
    values are:
</p>

<table class="table table-striped">
    <thead>
    <tr><th>NullOrder value</th><th>Meaning</th></tr>
    </thead>
    <tbody>
        <tr>
            <td>NullableOrder.NULL_SMALLEST</td>
            <td>
                Nulls are the smallest possible value.
                Nulls will appear the first if Order.ASC is
                defined or last if Order.DESC is defined. <strong>(Default behaviour)</strong>
            </td>
        </tr>
        <tr>
            <td>NullableOrder.NULL_BIGGEST</td>
            <td>
                Nulls are the biggest possible value. Nulls will appear the last if Order.ASC is
                defined or first if Order.DESC is defined
            </td>
        </tr>
    </body>
</table>

<p>
    The following examples shows how to declare the <code>NullOrder</code> in <code>OrderBy</code>
    definitions:
</p>

<pre class="prettyprint" id="java">
 new OrderBy().add("url", Order.DESC, NullOrder.NULL_BIGGEST);
</pre>


<p><a class="btn btn-primary btn-large" href="named_outputs.html">Next: Named outputs &raquo;</a></p>