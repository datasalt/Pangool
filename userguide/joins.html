---
layout: user_guide
title: Pangool - User guide - Reduce-side Joins
---
<div class="hero-unit">
	<h1>Pangool User Guide</h1>
</div>

<h1>Reduce-side Joins</h1>

<p>
One of the most interesting features of Pangool is its inherent reduce-side join capabilities.
</p>

<p>
 In this section we’ll comment one of the examples that can be found in the 
 <a href="https://github.com/datasalt/pangool/tree/master/examples">examples</a> sub-project of Pangool
  (<a href="https://github.com/datasalt/pangool/tree/master/examples/src/main/java/com/datasalt/pangool/examples/urlresolution/UrlResolution.java">the URL resolution example</a>)
   to illustrate how easy it is to perform arbitrary reduce-side joins with Pangool.
</p>

<p>
 We have one file with URL registers: [<code>url</code>, <code>timestamp</code>, <code>ip</code>] 
 and another file with canonical URL mappings: [<code>nonCanonicalUrl</code>, <code>canonicalUrl</code>].
 We want to output the URL registers file and have the url be substituted with the canonical 
 one according to the mapping file. In other words, we want the output to be like: [<code>canonicalUrl</code>, <code>timestamp</code>, <code>ip</code>]
</p>

<p>
For that, we need to join the URL registers file with the URL mappings one. 
To achieve that we need to join URL registers grouping by <code>url</code> and URL mappings grouping by <code>nonCanonicalUrl</code>. Using a reduce-side join, we 
could store the “canonicalUrl” for each group and apply the substitution 
to each of the URL registers records associated with that url. 
</p>
<p>
To make the join totally scalable, we need to receive the <code>canonicalUrl</code> first 
in each reduce group so that we only need to stream through the URL registers afterwards.
</p>

<p>
We’ll configure a Pangool Job to accept two inputs and therefore use two intermediate schemas. As we can parse the text input files directly using <a href='text_io.html'>Pangool's Text I/O</a>, we don't need to perform any specific mapping logic.
</p>

<pre class="prettyprint" id="java">
 TupleMRBuilder mr = new TupleMRBuilder(conf, "Pangool Url Resolution");
 mr.addIntermediateSchema(getURLMapSchema());
 mr.addIntermediateSchema(getURLRegisterSchema());
 mr.addInput(new Path(input1), new TupleTextInputFormat(getURLMapSchema(), false, false, '\t',
	NO_QUOTE_CHARACTER, NO_ESCAPE_CHARACTER, null, null), new IdentityTupleMapper());
 mr.addInput(new Path(input2), new TupleTextInputFormat(getURLRegisterSchema(), false, false, '\t', 
 	NO_QUOTE_CHARACTER, NO_ESCAPE_CHARACTER, null, null), new IdentityTupleMapper());
</pre>

<p>
Same thing for this one: just parsing and emitting a Tuple. 
Let’s now check to see the Reducer that performs the join:
</p>

<pre class="prettyprint" id="java">
 public static class Handler extends TupleReducer&lt;ITuple, NullWritable&gt; {

   private Tuple result;

   public void reduce(ITuple group, Iterable&lt;ITuple&gt; tuples, TupleMRContext context, Collector collector)
     throws IOException, InterruptedException, TupleMRException {
     if (result == null) {
       result = new Tuple(getURLRegisterSchema());
     }
     String cannonicalUrl = null;
     for(ITuple tuple : tuples) {
       if("urlMap".equals(tuple.getSchema().getName())) {
         cannonicalUrl = tuple.get("canonicalUrl").toString();
       } else {
		 result.set("url", cannonicalUrl);
		 result.set("timestamp", tuple.get("timestamp"));
		 result.set("ip", tuple.get("ip"));
		 collector.write(result, NullWritable.get());
       }
     }
   }
 }
</pre>

<p>
Let’s comment on this specific part of the code:
</p>

<pre class="prettyprint" id="java">
 for(ITuple tuple : tuples) {
   if("urlMap".equals(tuple.getSchema().getName())) {
     cannonicalUrl = tuple.get("canonicalUrl").toString();
   } else {
     ...     
   }
 }
</pre>

<p>
What happens is that we are iterating over each of the Tuples associated with the same 
<code>url</code> group, but we are keeping a state variable in case that the Tuple belongs 
to one of the schemas (the one that processed URL mapping registers).
Then, we use this state variable for emitting each of the URL registers.
 Note how we are assuming that the URL mapping comes always before the URL registers.
 In other words, there is a specific source sort within the records of the joined Tuple list. 
 We’ll see this in greater detail when we configure the job for that purpose.
</p>

<p>
Let’s now check how we configure the reduce-side join:
</p>

<pre class="prettyprint" id="java">
 builder.setFieldAliases("urlMap",new Aliases().add("url","nonCanonicalUrl"));
 builder.setGroupByFields("url");
 ...
</pre>

<div class="alert alert-info">
<p><b>Note:</b>
The specified fields in <code>setGroupByFields</code> must be present in all the intermediate 
schemas defined.If the field we want to group by is named differently among the schemas,like the case above,
then we must declare an alias for it, using <code><a href="http://pangool.net/apidocs/com/datasalt/pangool/tuplemr/TupleMRConfigBuilder.html#setFieldAliases(java.lang.String, com.datasalt.pangool.tuplemr.Aliases)">builder.setFieldAliases()</a></code> and use
that alias to group by, as it's shown above.<br/>
</p>
</div>
<p>
And that’s all! We have just defined two schemas and defined the group key. Note that even <code>url</code> 
field is not present in schema <code>urlMap</code>, there exists an alias <code>url</code> that refers to <code>nonCanonicalUrl</code>, so actually tuples are grouped by <code>nonCanonicalUrl</code>.
By default, Pangool will sort by the <i>groupBy</i> fields and will peform inter-source sorting based on the order in which we defined the sources.<br/> 
In this case, for each group, the URL mapping will come first - and that’s why the code above works. 
</p>

<p>
In order to configure a special sorting for the join, you’ll need to use <code>addSchemaOrder()</code>
as needed depending on which place you want to put the <i>inter-source</i> ordering in your custom sorting.
</p>
<p>
More info in <a href="group_and_sort.html">Group-By & Sort-By</a> section.
</p>
<p><a class="btn btn-primary btn-large" href="map_only_jobs.html">Next: Map-only Jobs &raquo;</a></p>