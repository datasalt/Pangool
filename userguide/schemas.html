---
layout: user_guide
title: Pangool - User guide - Tuples & Schemas
---
<div class="hero-unit">
	<h1>Pangool User Guide</h1>
</div>

<h1>Tuples & Schemas & Types</h1>

<p>
A Pangool Tuple is an ordered list of Objects with an associated Schema.
Schemas have an associated name and a list of Fields.
</p>
<p>
We can create an <code>Schema</code> in a strongly-typed fashion:
</p>
<pre class="prettyprint" id="java">
 List<Field> fields = new ArrayList<Field>();
 fields.add(Field.create("number1", Type.INT));
 fields.add(Field.create("string1", Type.STRING));
 fields.add(Field.create("string2", Type.STRING));
 Schema schema1 = new Schema("schema1", fields);
</pre>
<p>
Or we can also create it leveraging the <code>Fields.parse()</code> method:
</p>

<pre class="prettyprint" id="java">
 Schema schema1 = new Schema("schema1", Fields.parse("number1:int, string1:string, string2:string"));
</pre>
<p>

<h3>Types</h3>
<p>
Pangool supports any data type which is "Hadoop serializable", including <code>Writables</code>,
<a href="http://thrift.apache.org/">Thrift</a>, <a href="http://code.google.com/p/protostuff/">, ProtoStuff</a> and <a href="http://avro.apache.org/">Avro</a> objects. It natively supports some primitive types as well.
</p>

 <p>
The following table
summarizes the available field types:
</p>

<table class="table table-striped">
<thead>
	<tr><th>Field Type</th><th>Accepted java types</th><th>Deserialized java type</th><th>Serialization</th></tr>
</thead>
<tbody>
	<tr><td>Type.INT</td><td>Integer</td><td>Integer</td><td>32-bit integer (variable length encoded)</td></tr>
	<tr><td>Type.LONG</td><td>Long</td><td>Long</td><td>64-bit integer (variable length encoded)</td></tr>
	<tr><td>Type.FLOAT</td><td>Float</td><td>Float</td><td>32-bit floating number</td></tr>
	<tr><td>Type.DOUBLE</td><td>Double</td><td>Double</td><td>64-bit floating number</td></tr>
	<tr><td>Type.STRING</td><td>String, Utf8</td><td>Utf8</td><td>Integer encoded in variable length (size) + uft8 bytes</td></tr>
	<tr><td>Type.BOOLEAN</td><td>Boolean</td><td>Boolean</td><td>1-byte boolean type</td></tr>
	<tr><td>Type.ENUM</td><td>Enum</td><td>Enum</td><td>As Type.INT</td></tr>
	<tr><td>Type.BYTES</td><td>byte[],ByteBuffer</td><td>ByteBuffer</td><td>length encoded as Type.INT  + bytes</td>
	<tr>
		<td>Type.OBJECT</td>
		<td>Any serializable object</td>
		<td>As defined in Hadoop's (or custom) serialization</td>
		<td>
			length encoded as Type.INT  + serialized bytes
		</td>
	</tr>
</body>
</table>

<p>
<strong>Variable length integers and longs</strong> are encoded using less bytes for
smaller numbers than for bigger ones. The smallest numbers can fit in just one byte.
</p>

<h3>Objects</h3>

<p><br>
For non-primitive types you can use <code>Type.OBJECT</code> and set arbitrary objects.
There are two ways of serializing OBJECT fields:
<ul>
 <li><b>Using Hadoop's serialization:</b> The associated object's class will be used by Hadoop's serialization
 factory to choose the right serializers and deserializers defined in <code>io.serialization</code>:</li>
<p>
 <pre class="prettyprint" id="java">
  List<Field> fields = new ArrayList<Field>();
  fields.add(Field.createObject("obj", IntWritable.class));
  Schema schema1 = new Schema("schema1", fields);
 </pre>
 </p>
 <li><b>Setting custom serialization:</b> Pangool will use the serialization factory
 specified in the field's properties:</li>
 <p>
 <pre class="prettyprint" id="java">
  List<Field> fields = new ArrayList<Field>();
  Field field = Field.createObject("my_avro_field", Record.class);
  field.setSerialization(AvroFieldSerialization.class);
  field.addProps("avro.schema", myAvroSchema.toString());
  field.addProps("avro.reflection", false);
  Schema schema1 = new Schema("schema1", fields);
 </pre>
 </p>

 <div class="alert alert-info">
 <p>
 To know more about custom serialization take a look at <a href="custom_serialization.html">this section</a>.
 </div>
 </p>
</ul>
</p>
<br/>
<p>
<strong>Thrift / ProtoStuff</strong>
</p>

<p>
You can enable Pangool's native support for Thrift / ProtoStuff objects with:
</p>

<pre class="prettyprint" id="java">
 ThriftSerialization.enableThriftSerialization(conf);
 ProtoStuffSerialization.enableProtoStuffSerialization(conf);		
</pre>

<p>
Where <code>conf</code> is the Hadoop job configuration.
</p>

<h3>Tuples</h3>

<p>
Tuples meet the ITuple interface and can be instantiated via the Tuple class.
You can set tuple values by field name or field index.
</p>

<pre class="prettyprint" id="java">
 ITuple tuple = new Tuple(schema1);
 tuple.set("number1", 35);
 tuple.set("string1", "foo");
</pre>

<p>

</p>

<h4>Special getters</h4>

<p>
The following methods are available in Pangool Tuples in order to avoid explicit casting in users' code:
</p>

<pre class="prettyprint" id="java">
 public Integer getInteger(int pos);
 public Integer getInteger(String field);
	
 public Long getLong(int pos);
 public Long getLong(String field);
	
 public Float getFloat(int pos);
 public Float getFloat(String field);
	
 public Double getDouble(int pos);
 public Double getDouble(String field);
	
 public Boolean getBoolean(int pos);
 public Boolean getBoolean(String field);
	
 public String getString(int pos);
 public String getString(String field);
</pre>

<h4>Access by index</h4>

<p>
Tuples are just an ordered list of objects. You can access the elements
in the tuple by the index of the field as it was defined in the schema:
</p>

<pre class="prettyprint" id="java">
 tuple.set(1, "foo");
 tuple.get(1); // Will return "foo"
</pre>

<p>
That is, if the first field of you schema is "name", then you can get/set name
by accessing the position 0.
</p>

<h4>Strings</h4>

<p>
Users should always use <code>getString()</code> method, as strings may come sometimes as <code>Utf8</code> objects.
</p>

<p>
An alternative way of setting strings is the following:
</p>

<pre class="prettyprint" id="java">
 tuple.set("string1", new Utf8("foo"));
</pre>

<p>
The following code is right:
</p>

<pre class="prettyprint" id="java">
 Utf8 foo = new Utf8("foo");
 tuple.set("string1", foo);
 assertTrue(foo == tuple.get("string1");
	
 tuple.set("string1", "foo");
 assertTrue("foo".equals(tuple.get("string1"));
</pre>

<div class="alert alert">
<strong>Important:</strong> When Tuples come as an input of
<code>TupleMapper</code> or <code>TupleReducer</code>, strings will
always be wrapped by an <code>Utf8</code> object.
</div>

<h3>Nulls support</h3>

<p>
    Pangool supports null values in tuples <strong>since version 0.60.0</strong>. Any field can support null values, but
    it must be declared in the schema as nullable. The following example declares two fields,
    <code>nullableField</code> and <code>nullableObj</code> as nullable:
</p>

<pre class="prettyprint" id="java">
 List<Field> fields = new ArrayList<Field>();
 fields.add(Field.create("nullableField", Type.INT, true));
 fields.add(Field.createObject("nullableObj", IntWritable.class, true));
 Schema schema2 = new Schema("schema2", fields);
</pre>

<p>
    It is enough to add a <code>true</code> value as parameter at the end of the <code>Field.createX()</code> method
    calls to declare a field as nullable. Also, nullable fields can be declared using the <code>parse</code>
    method by adding the <code>?</code> character to the type declaration:
</p>

<pre class="prettyprint" id="java">
 Schema schema2 = new Schema("schema2", Fields.parse("nullableField:int?, nullableObj:org.apache.hadoop.io.IntWritable?"));
</pre>

<p>
    
</p>

<p>
</p>

<div class="alert alert-info">
    <strong>Advanced:</strong> Nulls support may have some effect on <strong>serialization length of Tuples</strong>. If none of
    the schema fields are nullable then there is no serialization overhead. But if at least one field is nullable then Pangool adds a bit field to the serialized form. The bit field
    length varies depending on the number of nullable fields in the schema. 1 byte bit field is enough for schemas with less than 8 nullable fields, 2 bytes for schemas between 7 and 14 nullable fields, and so on.
    When using more than one intermediate schema, the number of bytes used depends on the number of intermediate schemas with non-common nullable fields. 
</div>

<p><a class="btn btn-primary btn-large" href="TupleMrBuilder.html">Next: Creating Pangool Jobs &raquo;</a></p>

